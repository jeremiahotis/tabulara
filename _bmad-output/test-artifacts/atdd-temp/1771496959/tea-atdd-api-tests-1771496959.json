{
  "success": true,
  "subprocess": "atdd-api-tests",
  "tests": [
    {
      "file": "tests/api/story-1-4-apply-preprocessing-and-controlled-reprocessing.spec.ts",
      "content": "import { test, expect, type APIRequestContext } from '@playwright/test';\n\ntype CommandDispatchResponse = {\n  accepted?: boolean;\n  command_id?: string;\n  mutation_applied?: boolean;\n  event_appended?: boolean;\n  events?: Array<{\n    type?: string;\n    caused_by?: string;\n    data?: Record<string, unknown>;\n  }>;\n  documents?: Array<{\n    document_id?: string;\n  }>;\n  derived_artifacts?: Array<{\n    artifact_id?: string;\n    source_document_id?: string;\n    source_page_id?: string;\n  }>;\n  error?: {\n    code?: string;\n    details?: Array<{\n      field?: string;\n      reason?: string;\n    }>;\n  };\n};\n\nasync function dispatchCommand(request: APIRequestContext, command: Record<string, unknown>) {\n  return request.post('/api/v1/commands/dispatch', {\n    data: command,\n  });\n}\n\nasync function seedImportedDocument(request: APIRequestContext) {\n  const sessionId = 'session-preprocess-' + crypto.randomUUID();\n  const blobId = 'blob-preprocess-' + crypto.randomUUID();\n\n  const importCommand = {\n    command_id: crypto.randomUUID(),\n    command_type: 'ImportDocument',\n    payload: {\n      session_id: sessionId,\n      blob_ids: [blobId],\n      metadata: {\n        source: 'import',\n        file_name: 'preprocess-source.pdf',\n        mime_type: 'application/pdf',\n        file_hash: 'c'.repeat(64),\n      },\n    },\n  };\n\n  const importResponse = await dispatchCommand(request, importCommand);\n  expect(importResponse.status()).toBe(202);\n  const importBody = (await importResponse.json()) as CommandDispatchResponse;\n  const importedDocumentId = importBody.documents?.[0]?.document_id;\n\n  expect(importedDocumentId).toBeDefined();\n\n  return {\n    sessionId,\n    documentId: importedDocumentId as string,\n    sourceImportCommandId: importCommand.command_id,\n  };\n}\n\nfunction createApplyPreprocessingCommand(overrides: Partial<Record<string, unknown>> = {}) {\n  return {\n    command_id: crypto.randomUUID(),\n    command_type: 'ApplyPreprocessing',\n    payload: {\n      session_id: 'session-preprocess-default',\n      document_id: 'missing-document-id',\n      page_ids: ['page-1'],\n      preprocessing_profile: 'ocr-enhance',\n      ...overrides,\n    },\n  };\n}\n\nfunction createReprocessDocumentCommand(overrides: Partial<Record<string, unknown>> = {}) {\n  return {\n    command_id: crypto.randomUUID(),\n    command_type: 'ReprocessDocument',\n    payload: {\n      session_id: 'session-reprocess-default',\n      document_id: 'missing-document-id',\n      target_state: 'reprocessed',\n      reason: 'operator_requested_quality_upgrade',\n      ...overrides,\n    },\n  };\n}\n\ntest.describe('Story 1.4 preprocessing and controlled reprocessing command handlers (ATDD RED)', () => {\n  test.skip(\n    '[P0][AC1] should apply preprocessing, link derived artifacts to source pages, and append PreprocessingApplied in one transaction',\n    async ({ request }) => {\n      const context = await seedImportedDocument(request);\n      const command = createApplyPreprocessingCommand({\n        session_id: context.sessionId,\n        document_id: context.documentId,\n        page_ids: ['page-1', 'page-2'],\n        preprocessing_profile: 'ocr-enhance',\n      });\n\n      const response = await dispatchCommand(request, command);\n\n      expect(response.status()).toBe(202);\n      const body = (await response.json()) as CommandDispatchResponse;\n      expect(body).toMatchObject({\n        accepted: true,\n        command_id: command.command_id,\n        mutation_applied: true,\n        event_appended: true,\n        derived_artifacts: expect.arrayContaining([\n          expect.objectContaining({\n            artifact_id: expect.any(String),\n            source_document_id: context.documentId,\n            source_page_id: expect.any(String),\n          }),\n        ]),\n        events: expect.arrayContaining([\n          expect.objectContaining({\n            type: 'PreprocessingApplied',\n            caused_by: command.command_id,\n            data: expect.objectContaining({\n              session_id: context.sessionId,\n              document_id: context.documentId,\n            }),\n          }),\n        ]),\n      });\n    },\n  );\n\n  test.skip(\n    '[P0][AC1] should roll back mutation and event append when preprocessing artifact generation fails',\n    async ({ request }) => {\n      const context = await seedImportedDocument(request);\n      const command = createApplyPreprocessingCommand({\n        session_id: context.sessionId,\n        document_id: context.documentId,\n        preprocessing_profile: 'missing-profile',\n        force_fail_stage: 'artifact_generation',\n      });\n\n      const response = await dispatchCommand(request, command);\n\n      expect(response.status()).toBe(409);\n      const body = (await response.json()) as CommandDispatchResponse;\n      expect(body).toMatchObject({\n        error: {\n          code: 'PRECONDITION_FAILED',\n          details: expect.arrayContaining([\n            expect.objectContaining({\n              field: 'preprocessing_profile',\n              reason: 'profile_not_found',\n            }),\n          ]),\n        },\n        mutation_applied: false,\n        event_appended: false,\n      });\n    },\n  );\n\n  test.skip('[P1][AC1] should reject ApplyPreprocessing when referenced document does not exist', async ({ request }) => {\n    const command = createApplyPreprocessingCommand({\n      session_id: 'session-missing-' + crypto.randomUUID(),\n      document_id: 'missing-document-' + crypto.randomUUID(),\n      page_ids: ['page-1'],\n    });\n\n    const response = await dispatchCommand(request, command);\n\n    expect(response.status()).toBe(409);\n    const body = (await response.json()) as CommandDispatchResponse;\n    expect(body).toMatchObject({\n      error: {\n        code: 'PRECONDITION_FAILED',\n        details: expect.arrayContaining([\n          expect.objectContaining({\n            field: 'document_id',\n            reason: 'document_not_found',\n          }),\n        ]),\n      },\n      mutation_applied: false,\n      event_appended: false,\n    });\n  });\n\n  test.skip(\n    '[P0][AC2] should allow permitted reprocessing transition and append DocumentReprocessed while preserving existing history',\n    async ({ request }) => {\n      const context = await seedImportedDocument(request);\n      const applyCommand = createApplyPreprocessingCommand({\n        session_id: context.sessionId,\n        document_id: context.documentId,\n        page_ids: ['page-1'],\n        preprocessing_profile: 'ocr-enhance',\n      });\n      const applyResponse = await dispatchCommand(request, applyCommand);\n      expect(applyResponse.status()).toBe(202);\n\n      const reprocessCommand = createReprocessDocumentCommand({\n        session_id: context.sessionId,\n        document_id: context.documentId,\n        target_state: 'reprocessed',\n      });\n\n      const response = await dispatchCommand(request, reprocessCommand);\n\n      expect(response.status()).toBe(202);\n      const body = (await response.json()) as CommandDispatchResponse;\n      expect(body).toMatchObject({\n        accepted: true,\n        command_id: reprocessCommand.command_id,\n        mutation_applied: true,\n        event_appended: true,\n        events: expect.arrayContaining([\n          expect.objectContaining({\n            type: 'DocumentImported',\n          }),\n          expect.objectContaining({\n            type: 'DocumentReprocessed',\n            caused_by: reprocessCommand.command_id,\n            data: expect.objectContaining({\n              session_id: context.sessionId,\n              document_id: context.documentId,\n              target_state: 'reprocessed',\n            }),\n          }),\n        ]),\n      });\n    },\n  );\n\n  test.skip('[P0][AC2] should reject disallowed lifecycle transitions with deterministic guard errors', async ({ request }) => {\n    const context = await seedImportedDocument(request);\n    const command = createReprocessDocumentCommand({\n      session_id: context.sessionId,\n      document_id: context.documentId,\n      target_state: 'archived',\n    });\n\n    const response = await dispatchCommand(request, command);\n\n    expect(response.status()).toBe(409);\n    const body = (await response.json()) as CommandDispatchResponse;\n    expect(body).toMatchObject({\n      error: {\n        code: 'PRECONDITION_FAILED',\n        details: expect.arrayContaining([\n          expect.objectContaining({\n            field: 'lifecycle_state',\n            reason: 'transition_not_allowed',\n          }),\n        ]),\n      },\n      mutation_applied: false,\n      event_appended: false,\n    });\n  });\n\n  test.skip('[P1][AC2] should reject ReprocessDocument when referenced document is unknown', async ({ request }) => {\n    const command = createReprocessDocumentCommand({\n      session_id: 'session-missing-' + crypto.randomUUID(),\n      document_id: 'missing-document-' + crypto.randomUUID(),\n      target_state: 'reprocessed',\n    });\n\n    const response = await dispatchCommand(request, command);\n\n    expect(response.status()).toBe(409);\n    const body = (await response.json()) as CommandDispatchResponse;\n    expect(body).toMatchObject({\n      error: {\n        code: 'PRECONDITION_FAILED',\n        details: expect.arrayContaining([\n          expect.objectContaining({\n            field: 'document_id',\n            reason: 'document_not_found',\n          }),\n        ]),\n      },\n      mutation_applied: false,\n      event_appended: false,\n    });\n  });\n});\n",
      "description": "ATDD API tests for preprocessing and controlled reprocessing (RED PHASE)",
      "expected_to_fail": true,
      "acceptance_criteria_covered": [
        "ApplyPreprocessing creates derived artifacts linked to source pages",
        "PreprocessingApplied is appended in same command transaction",
        "ReprocessDocument enforces deterministic permitted transitions",
        "DocumentReprocessed appends while preserving existing audit history"
      ],
      "priority_coverage": {
        "P0": 4,
        "P1": 2,
        "P2": 0,
        "P3": 0
      }
    }
  ],
  "fixture_needs": [
    "story14ApplyPreprocessingPayloadFactory",
    "story14ReprocessDocumentPayloadFactory"
  ],
  "knowledge_fragments_used": [
    "api-request",
    "data-factories",
    "api-testing-patterns"
  ],
  "test_count": 6,
  "tdd_phase": "RED",
  "summary": "Generated 6 FAILING API tests for Story 1.4 preprocessing and controlled reprocessing"
}
